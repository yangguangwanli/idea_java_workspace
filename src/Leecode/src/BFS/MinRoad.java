package BFS;

import java.util.*;

public class MinRoad {
//那么究竟是怎样的一个实现过程及整体都需要什么步骤呢？

//准备工作：注意，这里包括了基本的bfs最短路径模板
//一个queue队列：核心
//一个int或者boolean的识别数组：用来标记已经访问过的节点，避免重复，必不可少！
	
//一个表示方向的int数组：看题意，如果可以8个方向全部都可轮循，数组的长度就为8，如果只能上下左右4个方向，长度就为4
//注：本题，我采用的是两个一维数组来表示方向
	
//private static int[] X = {0,1,1,1,0,-1,-1,-1};
//private static int[] Y = {1,1,0,-1,-1,-1,0,1};
//即x+X[0],y+Y[0],为右方向的轮循，后面依次顺时针，也可采用二维数组的形式
//private int[][] res = {{0,1},{1,1},{1,0},......};
//这样x+res[0][0],y+res[0][1],就表示右面，依次下去。
//
//下面我们来说bfs的具体队列是怎么实现的：
//1.将起点入队
//2.将起点（队首）可到达的节点全部入队，起点（队首）出队
//3.将队列的队首可到达的节点全部入队，队首出队
//
//依次下去，知道到达终点找到目标或者队列为空的时候，结束。
//
//根据步骤这里需要了解四点：
//
//1.队列里保存的是什么？
//一般我们会在队列里保存该入队节点的位置，因为这里需要用到坐标和方向嘛，所以是int[]的形式，不过并不唯一，可根据情况优化
//2.可到达的节点的条件？
//可到达就是依次轮循当前节点的8个方向找打值为0的节点，在本题中值为1的节点不可到达，值为0才可到达
//且既然会8个方向轮循就要考虑数组下标越界，要记得加上限制
//3.怎样避免重复到达的节点？
//我们已经访问过的节点必然不能再访问，这也是bfs的重中之重，这时我们准备阶段建立的识别数组就起作用了，我们建立一个与原数组等大的数组，这样就可以产生映射，一旦节点进了队列，就证明已经访问了，就要把节点在识别数组对应的标识，这里可以使用int数组，0为没访问，1为已访问。也可以boolean，用true和false。
//4.我们的最短路径呢？怎么表示出来？
//根据实例可知，只要起点没被堵，我们的路径step就是1了，也就是说step初值应为1，那么在什么时候递增呢？很显然，将队列中的节点轮循一遍后step应加1，这里如果不懂的话大家拿张纸，自己画个小地图，走一遍就明朗了。
//
//这样我们需要注意的细节就大概介绍完了，且基本的最短路径步骤也介绍完毕。
//
//具体实现大家根据代码体会，可记住重要步骤，因为很多bfs问题的步骤有很大重复，基本一致，可套用。

	public static void main(String[] args) {
		// TODO 自动生成的方法存根

	}

	class Solution {
		private int[] X = { 0, 1, 1, 1, 0, -1, -1, -1 };// 方向数组
		private int[] Y = { 1, 1, 0, -1, -1, -1, 0, 1 };
		private int m, n;// 方便记录长度而已，本题其实m和n是相等的。

		public int shortestPathBinaryMatrix(int[][] grid) {
			m = grid.length;
			n = grid[0].length;
			if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1)
				return -1;// 特殊情况特殊考虑，出口和入口被堵死
			if (m == 1 && grid[0][0] == 0)
				return 1;// 只有一个0的情况
			int[][] v = new int[m][n];// 识别数组
			Queue<int[]> a = new LinkedList<>();// 队列，里面保存int数组为坐标
			a.add(new int[] { 0, 0 });// 一开始将起点入队
			v[0][0] = 1;// 起点标记为已经访问
			int step = 1;// 理论上的初值
			while (!a.isEmpty()) {
				int s = a.size();// 为step叠加用
				for (int i = 0; i < s; i++) {
					int[] temp = a.poll();// poll()方法会自动获取队首元素，且获取完自动出队
					int x = temp[0];
					int y = temp[1];
					for (int j = 0; j < 8; j++) {
						int x1 = x + X[j];
						int y1 = y + Y[j];
						if (x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && grid[x1][y1] == 0 && v[x1][y1] != 1) {// 数组不越界，值为1，//没有被访问过才能入队
							a.add(new int[] { x1, y1 });// 入队
							v[x1][y1] = 1;// 标记已访问！！！！！！！！！！！！不要忘记
						}
					}
					if (x == m - 1 && y == n - 1)
						return step;// 终止条件
				}
				step++;
			}
			return -1;// 队列为空即为不能到达终点，返回-1
		}
	}
}
