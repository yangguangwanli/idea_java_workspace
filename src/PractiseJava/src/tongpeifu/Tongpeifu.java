package tongpeifu;

//难题
import java.util.Scanner;

//描述
//问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。
//要求：
//实现如下2个通配符：
//*：匹配0个或以上的字符（字符由英文字母，数字0-9和 '.' 组成，下同）
//？：匹配1个字符
//
//注意：匹配时不区分大小写。
//
//输入：
//通配符表达式；
//一组字符串。
//输出：
//
//返回不区分大小写的匹配结果，匹配成功输出true，匹配失败输出false
//
//本题含有多组样例输入！
//输入描述：
//先输入一个带有通配符的字符串，再输入一个需要匹配的字符串
//
//输出描述：
//返回不区分大小写的匹配结果，匹配成功输出true，匹配失败输出false
//
//示例1
//输入：
//te?t*.*
//txt12.xls
//
//输出：
//false
public class Tongpeifu {
	public static void main(String[] args) {
		// 先判断字符串s1的前缀；来决定f[0][0]的值是true还是false；
		// 如果s1[i]==‘?’直接就是f[i][j]=f[i-1][j-1];
		// 如果s1[i]=='*'有三种可能；
		// (1：匹配0个s2[j]，即f[i][j]=f[i-1][j]；
		// (2：匹配一个s2[j],即f[i][j]=f[i-1][j-1]；
		// (3：匹配多个s2[j]，即f[i][j]=f[i][j-1]；三种只要符合其中一种就是true
		// 如果s1[i]不是以上两种情况，且s1[i]==s2[i],则f[i][j]=f[i-1][j-1]；否则直接=false；
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			//存放数组
			//s1为通配表达式，s2为完全表达式
			char[] s1 = sc.next().toCharArray();
			char[] s2 = sc.next().toCharArray();
			//取出长度
			int m = s1.length;
			int n = s2.length;
			// dp[i][j]表示 s1从0到i处的字符与s2从0到j处的字符是否相匹配，标识符二维数组
			//此处用到了动态规划的知识
			//new boolean默认里面的数据为false
			boolean[][] dp = new boolean[m][n];
			//首先判断开头，开头为它的“根”值
			if (s1[0] == '*' || (s1[0] == '?' && s2.length != 0) || s1[0] == s2[0]) {
				dp[0][0] = true;
			}
			for (int i = 1; i < m; i++) {
				for (int j = 1; j < n; j++) {
					//循环对每个字符进行判断
					//？代表任意一个字符，所以这个字符是否匹配由之前的字符串是否匹配决定
					if (s1[i] == '?') {
						dp[i][j] = dp[i - 1][j - 1];
						// 对于 * 分为三种情况
						// (1：匹配0个字符s2[j]，即f[i][j]=f[i-1][j]；
						// (2：匹配一个字符s2[j],即f[i][j]=f[i-1][j-1]；
						// (3：匹配多个字符s2[j]，即f[i][j]=f[i][j-1]；
						//三种只要符合其中一种就是true，所以取 或 ||
					} else if (s1[i] == '*') {
						dp[i][j] = dp[i - 1][j] || dp[i - 1][j - 1] || dp[i][j - 1];
					} else {
						//如果本字符正确匹配，则是否为true由之前的字符串是否匹配决定
						if (s1[i] == s2[j]) {
							dp[i][j] = dp[i - 1][j - 1];
						}
					}
				}
			}
			//下标从0开始，所以-1
			//s1从0到m - 1处的字符与s2从0到n - 1处的字符是否相匹配，输出结果
			System.out.println(dp[m - 1][n - 1]);
		}
	}
}
