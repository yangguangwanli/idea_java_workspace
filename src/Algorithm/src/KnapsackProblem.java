
public class KnapsackProblem {
//	背包问题：有一个背包，容量为 4 磅 ， 现有如下物品
//	物品		重量		价格
//	吉他		1		1500
//	音响		4		3000
//	电脑		3		2000
//	
//	1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出
//	2) 要求装入的物品不能重复

//	思路分析和图解
//	1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出
//	2) 要求装入的物品不能重复
//	3) 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，
//	如何选择物品放入背包使物品的价值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用)
//	4) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。
//	5) 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，
//  根据 w[i]和 v[i]来确定是否需要将该物品放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j]
//	表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：
//	(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0
//	(2) 当 w[i]> j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个
//	单元格的装入策略
//	(3) 当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}
//	// 当 准备加入的新增的商品的容量小于等于当前背包的容量, // 装入的方式:
//	v[i-1][j]： 就是上一个单元格的装入的最大值
//	v[i] : 表示当前商品的价值
//	v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值
//	当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}
	
	
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		int[] w = {1, 4, 3};//物品的重量
		int[] val = {1500, 3000, 2000};
		String[] s = {"吉他", "音响", "电脑"};
		int m = 4;//b背包的容量
		int n = val.length;//物品的个数
		
		//为了记录放入商品的情况，我们定义一个二维数组
		int[][] path = new int[n+1][m+1];
		
		
		//创建二维数组
		//v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值
		int[][] v = new int[n + 1][m + 1];
		
		//初始化第一行和第一列，这里在本程序中，可以不去处理，因为默认为0
		for (int i = 0; i < v.length; i++) {
			v[i][0] = 0;
		}
		for (int i = 0; i < v[0].length;  i++) {
			v[0][i] = 0;//第一行设置为0
		}
		
		//根据前面得到的公式来动态规划
		for (int i = 1; i < v.length; i++) {//不处理第一行，i是从1开始的
			for (int j = 1; j < v[0].length; j++) {//不处理第一列，j是从1开始的
				//公式
				if (w[i-1] > j) {//因为我们的程序i是从1开始的，因此原来公式中的w[i]需要修改成w[i-1]
					v[i][j] = v[i-1][j];
				}else {
					//说明：
					//因为i从1 开始，因此公式需要调整为
					//以下
					//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i-1]]);
					//为了记录商品存放的情况，需要使用if else优化
					if (v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i-1]]) {
						v[i][j] = val[i - 1] + v[i - 1][j - w[i-1]];
						//把当前情况记录
						path[i][j] = 1;
					}else {
						v[i][j] = v[i - 1][j];
						path[i][j] = 1;
					}
				}
			}
		}
		
		//输出查看情况
		for (int i = 0; i < v.length; i++) {
			for (int j = 0; j < v[i].length; j++) {
				System.out.print(v[i][j] + " ");
			}
			System.out.println();
		}
		
		
		//输出最后放出的是哪些商品
		int i = path.length - 1;//行的最大下标
		int j = path[0].length - 1;//列的最大下标
		while (i > 0 && j > 0) {//从path的最后开始找
			if (path[i][j] == 1) {
				System.out.printf("%s " , s[i-1]);
				//System.out.printf("第%d个商品%s，放入到背包里面\n", i, s[i-1]);
				j -= w[i-1];//剩余的空间
			}
			i--;
		}
		
	}

}
